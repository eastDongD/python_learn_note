# 正则表达式
# 作用：匹配和切割字符串 此处所说的匹配都是match （后面有个search，和匹配不一样）
# 使用方法：首先构造正则表达式（即对字符串的要求），然后根据python的正则表达式模块的函数进行验证


# 字符匹配的意思应该是字符串从第一个字符开始即满足正则表达式，且能完整的走完整个正则表达式即匹配成功，不管字符串是否走完
# 故 正则"py" 可以匹配 python   显示<re.Match object; span=(0, 2), match='py'>
# 但是正则"py"不可以匹配 -python  显示None 因为第一个字符-不匹配p
# 若要限制完全匹配则加 ^ $如 正则"^py$" 不可以匹配python 显示： None


# 正则表达式的构造
# 先写对字符匹配的要求，再写对字符数量的要求
# 单字符匹配
#    在正则表达式中，如果直接给出字符，就是精确匹配（但是符号前要加反斜杠如 \,  \@   \+  \- 等，数字，字母外其他符号都被认为是特殊字符）
#   \d可以匹配一个数字
#   \w可以匹配一个字母或数字
#   .可以匹配任意字符
#   \s可以匹配一个空格（也包括Tab等空白符）
#   []更精确的匹配一个字符(注意[]表示的是从里面所有选择中选一个字符）。如  [0-9a-zA-Z\_]可以匹配一个数字、字母或者下划线  （下划线是特殊字符要加反斜杠）
#   A|B可以匹配A或B，所以(P|p)ython可以匹配'Python'或者'python' 括号()代表一个组，用于提取字符串时使用
#   ^表示行（字符串）的开头，^\d表示必须以数字开头
#   $表示行（字符串）的结束，\d$表示必须以数字结束     
# 字符长度要求
#   什么也不加，默认的情况下是就只有一个
#   *表示任意个字符（包括0个）  如 \d*代表任意个数字
#   +表示至少一个字符          如 \d+代表至少一个数字
#   ?表示0个或1个字符          如 \d?代表0个或者1个数字
#   {n}表示n个字符
#   {n,m}表示n-m个字符        如\d{3,6}代表3到6个数字
#    上述都是贪婪匹配，只要正则的一项还能匹配就不往正则的下一项匹配走，
#    加上?代表非贪婪匹配，只要正则的下一项能匹配（且后续各项正好能把正则正确匹配完），该项即使能匹配也不再匹配，而是用下一项去匹配
#    常用的非贪婪匹配：  尽可能少重复的意思是说： 只要正则的下一项能匹配（且后续各项正好能把正则正确匹配完），该项即使能匹配也不再匹配，而是用下一项去匹配
#    如re.match(r'^(\d+?)(0*)$', '102300').groups()  #('1023', '00')  第一个0断掉后面无法正确匹配，故不断，第二个0断掉后能完成匹配，故断掉
#    样例可看：  https://www.cnblogs.com/zhaogaojian/p/10320299.html
#    *? 重复任意次，但尽可能少重复
#    +? 重复1次或更多次，但尽可能少重复
#    ?? 重复0次或1次，但尽可能少重复
#    {n,m}? 重复n到m次，但尽可能少重复
#    {n,}? 重复n次以上，但尽可能少重复
# ()表示的是要提取的分组，这个是python切割字符串提取子串时使用的。如 '^(\d{3})-(\d{3,8})$' 匹配123-12345678通过python函数可以单独提取出123 和12345678


#样例
if False:
    '00\d'          #可以匹配'007'，但无法匹配'00A'；
    '\d\d\d'        #可以匹配'010'；
    '\w\w\d'        #可以匹配'py3'；
    'py.'           #可以匹配'pyc'、'pyo'、'py!'等等。
    "\d{3}\s+\d{3,8}"  #可以匹配 010 12345678
                    # \d{3}表示匹配3个数字，例如'010'；
                    # \s可以匹配一个空格（也包括Tab等空白符），所以\s+表示至少有一个空格，例如匹配' '，' '等
                    # \d{3,8}表示3-8个数字，例如'1234567'
    "\d{3}\-\d{3,8}" #匹配010-12345 （由于'-'是特殊字符，在正则表达式中，要用'\'转义）
    "[0-9a-zA-Z\_]" #可以匹配一个数字、字母或者下划线  下划线是特殊字符要加反斜杠
    "[0-9a-zA-Z\_]+"#可以匹配至少由一个数字、字母或者下划线组成的字符串，比如'a100'，'0_Z'，'Py3000'等等
    "[a-zA-Z\_][0-9a-zA-Z\_]*"#可以匹配由字母或下划线开头，后接任意个由一个数字、字母或者下划线组成的字符串
    "[a-zA-Z\_][0-9a-zA-Z\_]{0, 19}"#更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符）






# python中使用正则表达式（用于验证字符串是否合法，切分字符串，提取子串）及重复使用时，为了提高效率的预编译以及match和search区别
# Python提供re模块，包含所有正则表达式的功能
# 推荐正则表达式的字符串前加r前缀 （s = r'ABC\-001' 对应的正则表达式字符串为'ABC\-001'）
# （原因：Python的字符串本身也用\转义 所以字符串s = 'ABC\\-001'对应的正则表达式字符串变成'ABC\-001'。但是使用Python的r前缀，就不用考虑转义的问题）
# 引入re模块
# re.match(r"正则表达式字符串","要验证的字符串")  #match()方法判断是否匹配，如果匹配成功，返回一个Match对象，否则返回None
# 如：  re.match(r'^\d{3}\-\d{3,8}$', '010 12345')

if False:
    # 验证用户输入是否合法：
    import re
    test = '用户输入的字符串'
    if re.match(r'正则表达式', test):
        print('ok')
    else:
        print('failed')

    # 切分字符串:  
    re.split(r'\s+', 'a b   c') # ['a', 'b', 'c'] 无论多少个空格都可以正常分割
    re.split(r'[\s\,]+', 'a,b, c  d') #['a', 'b', 'c', 'd']
    re.split(r'[\s\,\;]+', 'a,b;; c  d') # ['a', 'b', 'c', 'd']
    #用正则表达式切分字符串比用固定的字符更灵活，请看正常的切分代码 print( 'a b   c'.split(' '))# ['a', 'b', '', '', 'c'] 无法识别连续的空格

    # 分组 即提取子串：
    # 用()表示的就是要提取的分组（Group）
    # 如 '^(\d{3})-(\d{3,8})$' 匹配123-12345678通过Match对象用group()方法单独提取出123 和12345678
    # 注意到group(0)永远是原始字符串，group(1)、group(2)……表示第1、2、……个子串
    m = re.match(r'^(\d{3})-(\d{3,8})$', '010-12345') #用()进行分组
    m.group(0) #'010-12345'
    m.group(1) # '010'
    m.group(2) #'12345'
    m.groups() # ('010', '12345')
    # 用正则表达式可以直接识别合法的时间
    t = '19:05:30'
    m = re.match(r'^(0[0-9]|1[0-9]|2[0-3]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$', t)
    m.groups() #('19', '05', '30')


    #正则匹配是贪婪匹配，也就是匹配尽可能多的字符。即从左到右依次匹配，尽可能多的匹配，不匹配再换下一个条件
    re.match(r'^(\d+)(0*)$', '102300').groups()    #结果为('102300', '')   由于\d+采用贪婪匹配，直接把后面的0全部匹配了，结果0*只能匹配空字符串了
    #如果让\d+采用非贪婪匹配（也就是尽可能少匹配），才能把后面的0匹配出来，加个?就可以让\d+采用非贪婪匹配
    re.match(r'^(\d+?)(0*)$', '102300').groups()  #('1023', '00')  第一个0断掉后面无法正确匹配，故不断，第二个0断掉后能完成匹配，故断掉


    # 如果一个正则表达式要重复使用几千次，出于效率的考虑，我们可以预编译该正则表达式，接下来重复使用时就不需要编译这个步骤了，直接匹配
    import re
    re_telephone = re.compile(r'^(\d{3})-(\d{3,8})$') # 编译:
    re_telephone.match('010-12345').groups() # 使用：
    re_telephone.match('010-8086').groups()
    #编译后生成Regular Expression对象，由于该对象自己包含了正则表达式，所以调用对应的方法时不用给出正则字符串。


    # match() 只有在0位置匹配成功的话才有返回.如果不是开始位置匹配成功的话，match()就返回None。
    # search()会扫描整个string查找匹配；search()会扫描整个字符串并返回第一个成功的匹配
    # search()也可以用正则匹配
    import re
    print(re.match("super", "superstition").span())     # 会返回(0, 5)
    print(re.match("super", "insuperable"))             # 则返回None
    print(re.search("super", "superstition").span())    # 返回(0, 5)
    print(re.search("super", "insuperable").span())     # 返回(2, 7)
    print(re.search("^\d+$","123456"))  #<re.Match object; span=(0, 6), match='123456'>